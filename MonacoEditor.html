<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monaco Editor</title>
  <script src="https://cdn.jsdelivr.net/npm/encoding-japanese/encoding.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
  <script src="https://unpkg.com/monaco-editor@0.52.0/min/vs/loader.js"></script>
  <script>const MONACO_URL = "https://unpkg.com/monaco-editor@0.52.0/min/vs"</script>
</head>

<body>
  <div id="toolbar">
    <div class="toolbar-group">
      <label for="languageSelector" title="ハイライト対象の言語を選択してください">言語</label>
      <select id="languageSelector" onchange="changeLanguage()" title="ハイライト対象の言語を選択してください">
        <option value="plaintext">テキスト</option>
        <option value="pli">IPO</option>
        <option value="html">HTML</option>
        <option value="javascript">JavaScript</option>
        <option value="css">CSS</option>
        <option value="vb">VB</option>
        <option value="markdown">Markdown</option>
        <option value="sql">SQL</option>
      </select>
    </div>
    <div class="toolbar-separator"></div>
    <div class="toolbar-group">
      <label for="tabSizeSelector" title="(SHIFT+)TABキーで字下げします">タブ</label>
      <select id="tabSizeSelector" onchange="changeTabSize()" title="(SHIFT+)TABキーで字下げします">
        <option value="2">2</option>
        <option value="4">4</option>
      </select>
    </div>
    <div class="toolbar-separator"></div>
    <div class="toolbar-group">
      <label for="encodingSelector" title="ファイル保存時の文字コード">文字</label>
      <select id="encodingSelector" title="ファイル保存時の文字コード">
        <option value="utf8">UTF8</option>
        <option value="sjis">SJIS</option>
      </select>
    </div>
    <div class="toolbar-separator"></div>
    <button class="icon-button" onclick="editor.trigger('', 'undo')" title="元に戻す(Ctrl+Z)">
      <svg viewBox="0 0 24 24">
        <path
          d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z" />
      </svg>
    </button>
    <button class="icon-button" onclick="editor.trigger('', 'redo')" title="やり直し(Ctrl+Y)">
      <svg viewBox="0 0 24 24">
        <path
          d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z" />
      </svg>
    </button>
    <div class="toolbar-separator"></div>
    <button class="icon-button" onclick="saveFile()" title="名前を付けて保存">
      <svg viewBox="0 0 24 24">
        <path
          d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm2 16H5V5h11.17L19 7.83V19zm-7-7c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3zM6 6h9v4H6z" />
      </svg>
    </button>
    <button class="icon-button" onclick="clearEditor()" title="エディタの内容をクリア">
      <svg viewBox="0 0 24 24">
        <path
          d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
      </svg>
    </button>
    <div class="toolbar-separator"></div>
    <button class="icon-button" onclick="getTargetEditor().trigger('', 'actions.find')" title="検索(Ctrl+F)">
      <svg viewBox="0 0 24 24">
        <path
          d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
      </svg>
    </button>
    <button class="icon-button" onclick="getTargetEditor().trigger('', 'editor.action.startFindReplaceAction')"
      title="置換(Ctrl+R)">
      <svg viewBox="0 0 24 24">
        <path
          d="M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z" />
      </svg>
    </button>
    <div class="toolbar-separator"></div>
    <div class="dropdown">
      <button class="icon-button" onclick="toggleCaseMenu()" title="文字種変換">
        <span
          style="font-family: 'Segoe UI', -apple-system, Roboto, sans-serif; font-size: 16px; font-weight: 600;">Aa</span>
      </button>
      <div id="caseMenu" class="dropdown-menu">
        <button onclick="convertCase('upper')">大文字に変換</button>
        <button onclick="convertCase('lower')">小文字に変換</button>
        <button onclick="convertCase('title')">先頭のみ大文字に変換</button>
        <button onclick="convertCase('fullWidth')">全角に変換</button>
        <button onclick="convertCase('halfWidth')">半角に変換</button>
      </div>
    </div>
    <div class="toolbar-separator"></div>
    <button class="icon-button" onclick="toggleBookmark()" title="ブックマークの設定/解除">
      <svg viewBox="0 0 24 24">
        <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z" />
      </svg>
    </button>
    <button class="icon-button" onclick="goToBookmark(1)" title="次のブックマークへ">
      <svg viewBox="0 0 24 24">
        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" />
      </svg>
    </button>
    <button class="icon-button" onclick="goToBookmark(-1)" title="前のブックマークへ">
      <svg viewBox="0 0 24 24">
        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" />
      </svg>
    </button>
    <button class="icon-button" onclick="clearAllBookmarks()" title="すべてのブックマークを解除">
      <svg viewBox="0 0 24 24">
        <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z" />
        <path d="M14.5 9.5L12 12l2.5 2.5-1 1L11 13l-2.5 2.5-1-1L10 12 7.5 9.5l1-1L11 11l2.5-2.5z" fill="white" />
      </svg>
    </button>
    <div class="toolbar-separator"></div>
    <button class="icon-button" onclick="toggleDiffEditor()" title="新旧差分を表示します" id="diffButton">
      新旧差分
    </button>
    <button class="icon-button diff-only" onclick="swapDiffSides()" title="左右を入れ替える">
      <svg viewBox="0 0 24 24">
        <path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z" />
      </svg> </button>
  </div>
  <div id="editor-container" ondragover="event.preventDefault();" ondragenter="handleDragEnter(event)"
    ondragleave="handleDragLeave(event)" ondrop="openFile(event)">
    <div id="editor"></div>
    <div id="preview"></div>
    <div class="drop-overlay">
      <div class="drop-message">ファイルをドロップしてください</div>
    </div>
  </div>
</body>

<style>
  #toolbar {
    padding: 4px;
    background-color: #f5f5f5;
    border-bottom: 1px solid #ddd;
    display: flex;
    align-items: center;
    user-select: none;
  }

  #editor-container {
    position: relative;
    height: calc(100vh - 50px);
    width: 100%;
  }

  #editor {
    width: 100%;
    height: 100%;
  }

  #editor.with-preview {
    width: 50%;
  }

  #preview {
    position: absolute;
    top: 0;
    right: 0;
    width: 50%;
    height: 100%;
    padding: 20px;
    overflow-y: auto;
    border-left: 1px solid #ccc;
    background-color: white;
    box-sizing: border-box;
    display: none;
    z-index: 100;
  }

  #preview.visible {
    display: block;
  }

  #toolbar select,
  #toolbar button {
    margin-right: 5px;
    padding: 3px;
  }

  .toolbar-group {
    display: inline-flex;
    margin-right: 1px;
    align-items: center;
  }

  .toolbar-group label {
    margin-right: 1px;
  }

  .icon-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    padding: 2px;
    margin: 0 1px;
    border: none;
    background: none;
    cursor: pointer;
    border-radius: 4px;
  }

  .icon-button:hover {
    background-color: #ddd;
    border-radius: 3px;
  }

  .icon-button svg {
    width: 20px;
    height: 20px;
    fill: currentColor;
  }

  #diffButton.active {
    background-color: #ccc;
    border-radius: 3px;
  }

  #diffButton {
    width: auto;
    padding: 2px 8px;
    border: 1px solid #888;
    border-radius: 5px;
  }

  .drop-overlay {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.2s ease;
    pointer-events: none;
  }

  .drop-overlay.active {
    display: flex;
    opacity: 1;
  }

  .toolbar-separator {
    width: 1px;
    height: 24px;
    background-color: #ccc;
    margin: 0 3px;
  }

  .bookmark-glyph {
    position: relative;
    margin-left: 0 !important;
    width: 20px !important;
    height: 20px !important;
  }

  .bookmark-glyph::after {
    content: '';
    position: absolute;
    left: 4px;
    top: 2px;
    width: 12px;
    height: 16px;
    background: #4169E1;
    mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z'/%3E%3C/svg%3E") center/contain no-repeat;
    -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z'/%3E%3C/svg%3E") center/contain no-repeat;
  }

  .function-separator {
    border-top: 1px solid #000;
    margin-top: 0px;
    padding-top: 0px;
  }

  /* マークダウンプレビューのスタイル */
  #preview pre {
    background-color: #f5f5f5;
    padding: 1em;
    border-radius: 5px;
    overflow-x: auto;
  }

  #preview code {
    background-color: #f5f5f5;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    font-size: 14px;
  }

  #preview blockquote {
    background-color: #f9f9f9;
    border-left: 4px solid #e0e0e0;
    padding: 10px 15px;
    margin: 20px 0;
    font-style: italic;
    color: #333;
  }

  #preview table {
    border-collapse: collapse;
    width: 100%;
  }

  #preview th,
  #preview td {
    border: 1px solid #ccc;
    padding: 2px;
  }

  #preview th {
    background-color: #f2f2f2;
  }

  #preview td {
    background-color: #ffffff;
  }

  #preview h1,
  #preview h2,
  #preview h3,
  #preview h4,
  #preview h5,
  #preview h6 {
    margin-top: 1em;
    margin-bottom: 0.5em;
    color: #333;
  }

  #preview p {
    margin: 1em 0;
    line-height: 1.5;
  }

  #preview ul,
  #preview ol {
    margin: 1em 0;
    padding-left: 2em;
  }

  .dropdown {
    position: relative;
    display: inline-block;
  }

  .dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    background-color: #f9f9f9;
    min-width: 160px;
    box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    border-radius: 4px;
    padding: 4px 0;
  }

  .dropdown-menu button {
    display: block;
    width: 100%;
    padding: 8px 16px;
    text-align: left;
    border: none;
    background: none;
    cursor: pointer;
  }

  .dropdown-menu button:hover {
    background-color: #e9e9e9;
  }

  .dropdown-menu.show {
    display: block;
  }

  /* 差分モード時のみ表示するボタンのスタイル */
  .diff-only {
    display: none;
  }
</style>

<script>
  let editor;
  let diffEditor;
  let lastFocused = null;  // 最後にフォーカスされたエディタを保持する変数
  let currentFileName = null;
  let originalContent = '';
  let isDiffMode = false;  // 差分表示モードのフラグを復活
  let bookmarkLines = new Set(); // ブックマークが設定された行を管理
  const editorDecorations = new WeakMap(); // WeakMapを追加
  const editorContainer = document.getElementById('editor-container');

  require.config({ paths: { 'vs': MONACO_URL } });
  require(['vs/editor/editor.main'], onEditorLoad);

  /**
   * Monaco Editorの初期化処理
   *
   * Monaco EditorのCoreモジュールをロードして、エディタのインスタンスを作成。
   * PL/Iのシンタックスハイライトルールを定義し、PL/Iもどきの言語設定を適用。
   * エディタの内容変更イベントをリッスンして、ブックマークの位置を更新。
   * エディタの内容が変更されたときや、言語が変更されたときの処理を定義。
   */
  function onEditorLoad() {
    // 通常のエディタを作成
    editor = monaco.editor.create(document.getElementById('editor'), {
      value: '',
      language: 'plaintext',
      theme: 'vs',
      lineNumbers: 'on',
      glyphMargin: true,
      folding: true
    });
    // PL/I言語の定義
    monaco.languages.register({ id: 'pli' });

    // PL/Iのシンタックスハイライトルールを定義
    monaco.languages.setMonarchTokensProvider('pli', {
      defaultToken: '',
      ignoreCase: true,

      // キーワード定義
      keywords: [
        'PROC', 'DECLARE', 'BEGIN', 'END', 'DO', 'TO', 'BY', 'WHILE', 'UNTIL', 'END', 'LEAVE',
        'IF', 'THEN', 'ELSE', 'ENDIF', 'SELECT', 'WHEN', 'OTHER', 'GO', 'TO', 'CALL', 'RETURN',
        'PUT', 'GET', 'SKIP', 'EDIT', 'PAGE', 'LIST', 'DATA', 'FLOW', 'BINARY', 'BIT',
        'CHARACTER', 'DECIMAL', 'FLOAT', 'FIXED', 'INITIAL', 'STATIC',
        'AUTOMATIC',
      ],

      tokenizer: {
        root: [
          // コメント
          [/\*.*$/, 'comment'],           // * で始まる行末までをコメントとして扱う
          [/「/, 'comment', '@comment'],   // 「でコメント開始

          // 文字列
          [/"([^"\\]|\\.)*$/, 'string.invalid'],  // 閉じていない文字列
          [/'([^'\\]|\\.)*$/, 'string.invalid'],  // 閉じていない文字列
          [/"/, 'string', '@string_double'],      // "で始まる文字列
          [/'/, 'string', '@string_single'],      // 'で始まる文字列

          // 数値
          [/[0-9]+/, 'number'],          // 整数
          [/[0-9]+\.[0-9]+/, 'number'],  // 小数

          // 識別子とキーワード
          [/[a-zA-Z_$][\w$]*/, {
            cases: {
              '@keywords': 'keyword',     // キーワードリストに含まれる場合
              '@default': 'identifier'    // それ以外は識別子として扱う
            }
          }]
        ],

        // コメントの状態
        comment: [
          [/」|\n/, 'comment', '@pop'],     // 」でコメント終了
          [/[^」]+/, 'comment'],         // 」以外の文字列
          [/./, 'comment']               // その他の文字
        ],

        // 文字列の状態（ダブルクォート）
        string_double: [
          [/[^\\"]+/, 'string'],         // 文字列の内容
          [/"/, 'string', '@pop'],       // "で文字列終了
          [/./, 'string']                // その他の文字
        ],

        // 文字列の状態（シングルクォート）
        string_single: [
          [/[^\\']+/, 'string'],         // 文字列の内容
          [/'/, 'string', '@pop'],       // 'で文字列終了
          [/./, 'string']                // その他の文字
        ]
      }
    });

    // PL/Iもどきの言語設定
    monaco.languages.setLanguageConfiguration('pli', {
      comments: {
        lineComment: '*',
        blockComment: ['「', '」']
      },
      brackets: [
        ['{', '}'],
        ['[', ']'],
        ['(', ')']
      ],
      autoClosingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: '"', close: '"' },
        { open: '\'', close: '\'' },
        { open: '「', close: '」' }
      ],
      surroundingPairs: [
        { open: '{', close: '}' },
        { open: '[', close: ']' },
        { open: '(', close: ')' },
        { open: '"', close: '"' },
        { open: '\'', close: '\'' },
        { open: '「', close: '」' }
      ],
      folding: {
        markers: {
          start: new RegExp(/^\s*[\w$]+:\s*proc;/i),
          end: new RegExp(/^\s*end\s+proc/i)
        }
      }
    });

    // エディタの内容変更イベントをリッスン
    editor.getModel().onDidChangeContent((e) => {
      // 変更された行の情報を取得して、ブックマークの位置を更新
      for (const change of e.changes) {
        const startLineNumber = change.range.startLineNumber;
        const endLineNumber = change.range.endLineNumber;
        const lineCount = change.text.split('\n').length - 1;
        updateBookmarkPositions(startLineNumber, endLineNumber, lineCount);
      }
    });

    // エディタの内容が変更されたときの処理
    editor.onDidChangeModelContent(updateEditorUI);
    // エディタの言語が変更されたときの処理
    editor.onDidChangeModelLanguage(updateEditorUI);

    // 'pli'用シンボル情報提供用のCallback関数を登録
    monaco.languages.registerDocumentSymbolProvider('vb', { provideDocumentSymbols });
    function provideDocumentSymbols(model, token) {
      const symbols = [];
      const START_PATTERN = '(?:private|public)? *(?:function|sub|property) +(\\w+).*';// 関数の開始行
      const END_PATTERN = '(end) +(?:function|sub|property)\\b';// 関数の終了行
      const functionRegex = new RegExp(`^ *(?:${START_PATTERN}|${END_PATTERN})`, 'igm');
      // コード内容を取得
      const codeContent = model.getValue();
      // 終了行を先に取得するため後方から配列に格納する
      const matches = Array.from(codeContent.matchAll(functionRegex)).reverse();
      let endLine = 0; // 終了行を格納する変数

      matches.forEach(match => {
        const line = model.getPositionAt(match.index + 1).lineNumber;

        // match[2] が 'end' の場合（終了行）
        if (match[2]?.toLowerCase() === 'end') {
          endLine = line; // 終了行を格納
          return;
        }

        // match[1] が有効な場合（開始行）
        if (match[1]) {
          symbols.push({
            name: match[1],
            kind: monaco.languages.SymbolKind.Function,
            range: {
              startLineNumber: line,
              startColumn: 1,
              endLineNumber: endLine || line,
              endColumn: 1
            },
            selectionRange: {
              startLineNumber: line,
              startColumn: 1,
              endLineNumber: line,
              endColumn: 1
            },
            // detail: '詳細情報（オプション）',
          });
        }
        endLine = 0;
      });
      return symbols;
    }

    // 'pli'用の定義提供用のCallback関数を登録
    monaco.languages.registerDefinitionProvider("vb", { provideDefinition });
    function provideDefinition(model, position, token) {
      // カーソル位置の行を取得
      const lineContent = model.getLineContent(position.lineNumber);
      // 行が 'call' で始まるか確認し、関数名を抽出
      const match = lineContent.trim().match(/^call\s+(\w+)/i);
      if (!match) return;
      const functionName = match[1];

      // 関数名に該当する行を検索
      const lines = model.getLinesContent();
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(new RegExp(`(?:function|sub)\\s+${functionName}`, 'i'))) {
          return {
            uri: model.uri,
            // 該当行の全体を range に設定
            range: new monaco.Range(i + 1, 1, i + 1, lines[i].length + 1),
          };
        }
      }
    }

    // 'pli'用の参照提供用のCallback関数を登録
    monaco.languages.registerReferenceProvider("vb", { provideReferences });
    function provideReferences(model, position, context, token) {
      // カーソル位置の行を取得
      const lineContent = model.getLineContent(position.lineNumber);
      let match;
      // 行が関数の開始行か確認し、関数名を抽出
      match = lineContent.trim().match(/^(?:private|public)? *(?:function|sub|property) +(\w+).*/i);
      if (!match) {
        // 行が 'call' で始まるか確認し、関数名を抽出
        match = lineContent.trim().match(/^call\s+(\w+)/i);
      }
      if (!match) return;
      const functionName = match[1];

      // 関数名が呼び出されている行と定義されている行をすべて検索
      const lines = model.getLinesContent();
      const references = [];
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].match(new RegExp(`call\\s+${functionName}`, 'i')) ||
          lines[i].match(new RegExp(`(?:function|sub)\\s+${functionName}`, 'i'))) {
          references.push({
            uri: model.uri,
            range: new monaco.Range(i + 1, 1, i + 1, lines[i].length + 1),
          });
        }
      }
      return references;
    }

    // キー割り当てを変更する
    monaco.editor.addKeybindingRules([{
      // Ctrl+[ に editor.action.jumpToBracket を割り当て
      keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyCode.BracketLeft,
      command: 'editor.action.jumpToBracket'
    }, {
      // Ctrl+] に editor.action.jumpToBracket を割り当て
      keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyCode.BracketRight,
      command: 'editor.action.jumpToBracket'
    }, {
      // Ctrl+Shift+\ に editor.action.selectToBracket を割り当て
      keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.Backslash,
      command: 'editor.action.selectToBracket'
    }]);
  }

  /**
   * Monaco EditorのUIを更新する。
   * 関数区切り線を更新し、プレビューを更新する。
   */
  function updateEditorUI() {
    // 関数区切り線を更新
    updateFunctionDecorations(editor);
    // プレビューを更新
    updatePreview();
  }

  const dropOverlay = document.querySelector('.drop-overlay');
  let dragCounter = 0;
  /**
   * ドラッグエンターイベントを処理します。デフォルトの動作を防止し、
   * dragCounterをインクリメントし、アイテムがターゲットエリアに最初にドラッグされたときに
   * ドロップオーバーレイをアクティブにします。
   *
   * @param {Event} e - ドラッグエンターイベントオブジェクト
   */
  function handleDragEnter(e) {
    e.preventDefault();
    dragCounter++;
    if (dragCounter === 1) {
      dropOverlay.classList.add('active');
    }
  }
  /**
   * ドラッグエンターイベントを処理します。デフォルトの動作を防止し、
   * dragCounterをデクリメントし、アイテムがターゲットエリアから最後にドラッグされたときに
   * ドロップオーバーレイを非アクティブにします。
   *
   * @param {Event} e - ドラッグエンターイベントオブジェクト
   */
  function handleDragLeave(e) {
    e.preventDefault();
    dragCounter--;
    if (dragCounter === 0) {
      dropOverlay.classList.remove('active');
    }
  }
  /**
   * ファイルを開く。
   * ドラッグ&ドロップのドロップ領域を示す要素。
   * ドラッグ&ドロップのドロップ領域にドロップされたら、ドロップされたファイルを開く。
   * @param {Event} e - ドラッグ&ドロップのドロップイベントオブジェクト
   */
  async function openFile(e) {
    e.preventDefault();
    dragCounter = 0;
    dropOverlay.classList.remove('active');

    const file = e.dataTransfer.files[0];
    if (file) {
      currentFileName = file.name;
      document.title = file.name;

      // 文字コードを自動判別
      const detectedEncoding = await detectEncoding(file);
      // ファイルを読み込む
      document.getElementById('encodingSelector').value = detectedEncoding;
      const content = await readFileContent(file, detectedEncoding);

      // ファイル拡張子に基づいて言語を設定
      const extension = file.name.split('.').pop().toLowerCase();

      if (extension === 'diff') {
        const showDiff = await new Promise(resolve => {
          if (confirm('差分モードで開きますか？')) {
            resolve(true);
          } else {
            resolve(false);
          }
        });

        // 差分モードで開く
        if (showDiff) {
          openInDiffMode(content);
          return;
        }
      }

      const languageMap = {
        'js': 'javascript',
        'html': 'html',
        'css': 'css',
        'vb': 'vb',
        'bas': 'vb',
        'cls': 'vb',
        'vbs': 'vb',
        'csv': 'csv',
        'txt': 'plaintext',
        'sql': 'sql',
        'md': 'markdown',
        'ipo': 'pli'
      };

      const currentLanguage = languageMap[extension] || 'plaintext';
      document.getElementById('languageSelector').value = currentLanguage;
      monaco.editor.setModelLanguage(editor.getModel(), currentLanguage);
      if (!isDiffMode) originalContent = content;
      editor.setValue(content);
    }

    // ブックマークをクリア
    clearAllBookmarks();
    // マークダウン画面を必要に応じて更新
    updatePreview();
    // タブサイズを更新
    changeTabSize();
    // エディタのレイアウトを更新
    layoutEditor();
  }

  /**
   * エディタのレイアウトを更新
   */
  function layoutEditor() {
    if (editor) editor.layout();
    if (diffEditor) diffEditor.layout();
  }

  /**
   * 関数区切り線を追加
   * @param {monaco.editor.IStandaloneCodeEditor} targetEditor - 対象のエディタ
   */
  function updateFunctionDecorations(targetEditor) {
    if (!targetEditor || !targetEditor.getModel()) {
      return;
    }
    // 言語ごとの関数区切りパターン
    const functionPatterns = {
      'vb': /^\s*(private\s+|public\s+|protected\s+|friend\s+)?(function|sub|property)\s+/i,
      'sql': /^\s*(create\s+)?(procedure|function|trigger|view)\s+/i,
      'javascript': /^\s*(async\s+)?(function\s+[\w$]+|\w+\s*=\s*(async\s+)?function\s*|class\s+[\w$]+)/i,
      'html': /^\s*(async\s+)?(function\s+[\w$]+|\w+\s*=\s*(async\s+)?function\s*|class\s+[\w$]+)/i,
      'pli': /^\s*[\w$]+:\s*proc;/i
    };
    const languageId = targetEditor.getModel().getLanguageId();
    const pattern = functionPatterns[languageId];

    // 現在のエディタの装飾情報を取得（なければ空配列）
    const currentDecorations = editorDecorations.get(targetEditor) || [];

    if (!pattern) {
      targetEditor.deltaDecorations(currentDecorations, []);
      editorDecorations.set(targetEditor, []);
      return;
    }
    const text = targetEditor.getValue();
    const lines = text.split('\n');
    const newDecorations = [];

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(pattern)) {
        newDecorations.push({
          range: new monaco.Range(i + 1, 1, i + 1, 1),
          options: {
            isWholeLine: true,
            className: 'function-separator',
          }
        });
      }
    }

    // 新しい装飾情報を保存
    const decorationIds = targetEditor.deltaDecorations(currentDecorations, newDecorations);
    editorDecorations.set(targetEditor, decorationIds);
  }

  /**
   * バイト配列がUTF-8かどうかを判定する
   * @param {Uint8Array} bytes - 判定対象のバイト配列
   * @returns {boolean} UTF-8かどうか
   */
  function isUtf8(bytes) {
    // UTF-8のBOMチェック
    if (bytes.length >= 3 && bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
      return true;
    }

    let i = 0;
    while (i < bytes.length) {
      if (bytes[i] === 0x00) return false; // nullバイトがあればSJISの可能性が高い

      if ((bytes[i] & 0x80) === 0) { // ASCII
        i++;
      } else if ((bytes[i] & 0xE0) === 0xC0) { // 2バイト文字
        if (i + 1 >= bytes.length) return false;
        if ((bytes[i + 1] & 0xC0) !== 0x80) return false;
        i += 2;
      } else if ((bytes[i] & 0xF0) === 0xE0) { // 3バイト文字
        if (i + 2 >= bytes.length) return false;
        if ((bytes[i + 1] & 0xC0) !== 0x80) return false;
        if ((bytes[i + 2] & 0xC0) !== 0x80) return false;
        i += 3;
      } else if ((bytes[i] & 0xF8) === 0xF0) { // 4バイト文字
        if (i + 3 >= bytes.length) return false;
        if ((bytes[i + 1] & 0xC0) !== 0x80) return false;
        if ((bytes[i + 2] & 0xC0) !== 0x80) return false;
        if ((bytes[i + 3] & 0xC0) !== 0x80) return false;
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }

  /**
   * プレビューを更新する
   */
  function updatePreview() {
    const language = document.getElementById('languageSelector').value;
    const preview = document.getElementById('preview');
    const editorDiv = document.getElementById('editor');

    if (language !== 'markdown' || isDiffMode) {
      preview.classList.remove('visible');
      editorDiv.classList.remove('with-preview');
      return;
    }
    preview.classList.add('visible');
    editorDiv.classList.add('with-preview');

    // marked.jsの設定
    marked.setOptions({
      breaks: true,  // 改行を有効に
      gfm: true     // GitHub Flavored Markdownを有効に
    });
    const content = editor.getValue();
    preview.innerHTML = marked.parse(content || '');

    // コードブロックにシンタックスハイライトを適用
    document.querySelectorAll('#preview pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  }

  /**
   * 言語が変更されたときの処理
   */
  function changeLanguage() {
    const language = document.getElementById('languageSelector').value;

    if (editor && editor.getModel()) {
      monaco.editor.setModelLanguage(editor.getModel(), language);
      // エディタとモデルが存在する場合のみ関数装飾を更新
      updateFunctionDecorations(editor);
    }
    // 言語に関係なくプレビューを更新
    updatePreview();
    // エディタのレイアウトを更新
    layoutEditor();
  }

  /**
   * ファイルの文字コードを自動判別する
   * @param {File} file - 判別対象のファイル
   * @returns {Promise<string>} 判別された文字コード
   */
  async function detectEncoding(file) {
    const buffer = await file.arrayBuffer();
    const bytes = new Uint8Array(buffer);
    return isUtf8(bytes) ? 'utf8' : 'sjis';
  }

  // 概要: ファイルの内容を指定された文字コードで読み込む
  async function readFileContent(file, encoding) {
    const buffer = await file.arrayBuffer();
    const decoder = new TextDecoder(encoding === 'utf8' ? 'utf-8' : 'shift-jis');
    return decoder.decode(buffer);
  }

  /**
   * ウィンドウのリサイズイベントを監視し、エディタを再描画する
   */
  window.addEventListener('resize', layoutEditor);

  /**
   * 差分モードでファイルを開く
   * @param {string} content - ファイルの内容
   */
  function openInDiffMode(content) {
    // 言語判定
    const languageMatch = content.match(/```(\w+)/);
    const language = languageMatch ? languageMatch[1] : '';

    // 行ごとに処理
    const lines = content.split('\n');
    let blockCnt = 0; // 1:original処理中 3:modified処理中
    const originalLines = [];
    const modifiedLines = [];

    for (const line of lines) {
      if (line.startsWith('```')) {
        blockCnt++;
        // ```行はスキップ
        continue;
      }

      if (blockCnt === 1) {
        originalLines.push(line.substring(1));
      } else if (blockCnt === 3) {
        modifiedLines.push(line.substring(1));
      }
    }

    // 言語を設定
    const languageSelector = document.getElementById('languageSelector');
    if (languageSelector && language) {
      languageSelector.value = language;
      changeLanguage();
    }

    // 内容を設定
    originalContent = originalLines.join('\n');
    editor.setValue(modifiedLines.join('\n'));

    // 差分エディタを表示
    isDiffMode = false;
    toggleDiffEditor();
    changeTabSize();
  }

  /**
   * 差分表示モードの切り替えを行う
   */
  function toggleDiffEditor() {
    isDiffMode = !isDiffMode;

    if (isDiffMode) {
      const editorContainer = document.getElementById('editor-container');
      // 差分エディタを作成
      diffEditor = monaco.editor.createDiffEditor(editorContainer, {
        // オプション設定
        enableSplitViewResizing: true,
        renderSideBySide: true,
        originalEditable: true,
        glyphMargin: true  // Modified Editorの行番号横のアイコン表示のために必要
      });

      // 現在の言語設定を取得
      const currentLanguage = editor.getModel().getLanguageId();

      // 元のコンテンツと現在のコンテンツを設定（同じ言語を適用）
      const originalModel = monaco.editor.createModel(originalContent, currentLanguage);
      const modifiedModel = editor.getModel();
      diffEditor.setModel({
        original: originalModel,
        modified: modifiedModel
      });

      // 関数区切り線を両方のエディタに追加
      updateFunctionDecorations(diffEditor.getOriginalEditor());
      updateFunctionDecorations(diffEditor.getModifiedEditor());

      // Modified Editorにブックマークの装飾を適用
      updateBookmarkDecorations(diffEditor.getModifiedEditor());

      // 差分エディタのコンテンツ変更時に更新
      diffEditor.getModifiedEditor().onDidChangeModelContent(() => {
        updateFunctionDecorations(diffEditor.getModifiedEditor());
        updateBookmarkDecorations(diffEditor.getModifiedEditor());
      });

      // フォーカスイベントの設定
      diffEditor.getOriginalEditor().onDidFocusEditorText(() => {
        lastFocused = diffEditor.getOriginalEditor();
      });

      diffEditor.getModifiedEditor().onDidFocusEditorText(() => {
        lastFocused = diffEditor.getModifiedEditor();
      });
    } else {
      // 差分エディタを破棄
      if (diffEditor) {
        const modifiedModel = diffEditor.getModifiedEditor().getModel();
        const originalModel = diffEditor.getOriginalEditor().getModel();
        originalContent = originalModel.getValue();
        diffEditor.dispose();
        // 修正されたモデルを保持
        editor.setModel(modifiedModel);
      }
      // 通常エディタのブックマークを更新
      updateBookmarkDecorations(editor);
    }

    const diffButton = document.getElementById('diffButton');
    if (isDiffMode) {
      // 元のエディタを非表示
      editor.getContainerDomNode().style.display = 'none';
      diffButton.classList.add('active');
    } else {
      // 元のエディタを表示
      editor.getContainerDomNode().style.display = 'block';
      diffButton.classList.remove('active');
    }

    // 差分モード用のボタンを表示/非表示を切り替え
    document.querySelectorAll('.diff-only').forEach(button => {
      if (isDiffMode) {
        button.style.display = 'inline-flex';
      } else {
        button.style.display = 'none';
      }
    });

    // マークダウン画面を必要に応じて更新
    updatePreview();
    // エディタのレイアウトを更新
    layoutEditor();
  }

  /**
   * 差分エディタの左右を入れ替える関数
   */
  function swapDiffSides() {
    if (!diffEditor) return;

    const originalModel = diffEditor.getOriginalEditor().getModel();
    const modifiedModel = diffEditor.getModifiedEditor().getModel();

    // モデルの内容を取得
    originalContent = modifiedModel.getValue();
    const modifiedContent = originalModel.getValue();

    // 内容を入れ替え
    originalModel.setValue(originalContent);
    modifiedModel.setValue(modifiedContent);

    // 関数区切り線を両方のエディタに追加
    updateFunctionDecorations(diffEditor.getOriginalEditor());
    updateFunctionDecorations(diffEditor.getModifiedEditor());

  }

  /**
   * エディタの言語モードを変更する
   */
  function changeTabSize() {
    const selectedTabSize = parseInt(document.getElementById('tabSizeSelector').value);
    if (editor) {
      editor.getModel().updateOptions({ tabSize: selectedTabSize });
      if (isDiffMode) {
        const diffModel = diffEditor.getModel();
        diffModel.modified.updateOptions({ tabSize: selectedTabSize });
        diffModel.original.updateOptions({ tabSize: selectedTabSize });
      }
    }
    // エディタのレイアウトを更新
    layoutEditor();
  }

  /**
   * 現在のエディタの内容をファイルとして保存する
   */
  async function saveFile() {
    let finalArray, fileName;
    [finalArray, fileName] = isDiffMode ? createDiffFileData() : createFileData();
    fileName = prompt('ファイル名を入力してください', fileName);
    if (!fileName) return;

    try {
      // Blobを作成して保存
      const blob = new Blob([finalArray], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fileName;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    } catch (error) {
      console.error('ファイル保存エラー:', error);
      alert('ファイルの保存中にエラーが発生しました。');
    }
  }

  /**
   * 差分ファイルのデータを生成する
   */
  function createDiffFileData() {
    const currentLanguage = editor.getModel().getLanguageId();
    const originalText = diffEditor.getOriginalEditor().getValue()
      .split('\n').map(line => ' ' + line).join('\n');
    const modifiedText = diffEditor.getModifiedEditor().getValue()
      .split('\n').map(line => ' ' + line).join('\n');
    const content = `
\`\`\`${currentLanguage}
${originalText}
\`\`\`

\`\`\`${currentLanguage}
${modifiedText}
\`\`\`
`;

    const finalArray = new TextEncoder().encode(content);
    let fileName;
    if (currentFileName) {
      // 現在のファイル名から拡張子を除去
      const baseFileName = currentFileName.replace(/\.[^/.]+$/, '');
      fileName = baseFileName + '.diff';
    } else {
      fileName = '差分.diff';
    }
    return [finalArray, fileName];
  }

  /**
   * ファイルのデータを生成する
   */
  function createFileData() {
    const content = editor.getValue();
    const encoding = document.getElementById('encodingSelector').value;
    let finalArray;
    if (encoding === 'sjis') {
      const shiftJisArray = Encoding.convert(Encoding.stringToCode(content), 'SJIS');
      finalArray = new Uint8Array(shiftJisArray);
    } else {
      finalArray = new TextEncoder().encode(content);
    }
    const languageMap = {
      'javascript': '.js',
      'html': '.html',
      'css': '.css',
      'vb': '.vb',
      'csv': '.csv',
      'plaintext': '.txt',
      'sql': '.sql',
      'markdown': '.md',
      'pli': '.ipo'
    };
    const currentLanguage = editor.getModel().getLanguageId();
    const extension = languageMap[currentLanguage] || '.txt';
    const fileName = currentFileName || `untitled${extension}`;
    return [finalArray, fileName];
  }

  /** 
   * エディタの内容をクリアし、初期状態に戻す
   */
  function clearEditor() {
    if (confirm('エディタの内容をクリアしますか？\nクリアすればundoは出来ません')) {
      location.reload();
    }
  }

  /** 
   * ブックマークの設定/解除を切り替える
   */
  function toggleBookmark() {
    const targetEditor = getTargetEditor();
    // オリジナルエディタの時return
    if (isDiffMode && targetEditor === diffEditor.getOriginalEditor()) return;

    const position = targetEditor.getPosition();
    const lineNumber = position.lineNumber;
    const column = position.column;

    if (bookmarkLines.has(lineNumber)) {
      bookmarkLines.delete(lineNumber);
    } else {
      bookmarkLines.add(lineNumber);
    }
    updateBookmarkDecorations(targetEditor);

    targetEditor.focus();
    targetEditor.setPosition({ lineNumber, column });
  }

  /**
   * 指定された方向の次のブックマークにジャンプ
   * @param {number} direction - ジャンプする方向(正:次のブックマーク、負:前のブックマーク)
   */
  function goToBookmark(direction) {
    const targetEditor = getTargetEditor();
    // オリジナルエディタの時return
    if (isDiffMode && targetEditor === diffEditor.getOriginalEditor()) return;

    const currentLine = targetEditor.getPosition().lineNumber;
    const bookmarkArray = Array.from(bookmarkLines).sort((a, b) => direction * (a - b));

    // 現在の行から指定された方向にあるブックマークを探す
    const nextBookmark = bookmarkArray.find(line => direction * (line - currentLine) > 0) || bookmarkArray[0]
    targetEditor.setPosition({ lineNumber: nextBookmark, column: 1 });
    targetEditor.revealLineInCenter(nextBookmark);
    targetEditor.focus(); // エディタにフォーカスを戻す
  }

  /**
   * すべてのブックマークを解除
   */
  function clearAllBookmarks() {
    bookmarkLines.clear();
    updateBookmarkDecorations(editor);
    editor.focus(); // エディタにフォーカスを戻す
  }

  /**
   * ブックマークの装飾を更新
   * @param {monaco.editor.IEditor} targetEditor - 更新対象のエディタ
   */
  function updateBookmarkDecorations(targetEditor) {
    const decorations = Array.from(bookmarkLines).map(line => ({
      range: new monaco.Range(line, 1, line, 1),
      options: {
        glyphMarginClassName: 'bookmark-glyph'
      }
    }));

    // 既存の装飾をすべて削除して新しい装飾を設定
    const oldDecorations = targetEditor.getModel().getAllDecorations()
      .filter(d => d.options.glyphMarginClassName === 'bookmark-glyph')
      .map(d => d.id);

    targetEditor.deltaDecorations(oldDecorations, decorations);
  }

  /**
   * 行の追加/削除に応じてブックマークの位置を更新
   * @param {number} startLine - 変更された行の開始行
   * @param {number} endLine - 変更された行の終了行
   * @param {number} lineCount - 変更された行数
   */
  function updateBookmarkPositions(startLine, endLine, lineCount) {
    const oldBookmarks = Array.from(bookmarkLines);
    bookmarkLines.clear();

    for (const line of oldBookmarks) {
      if (line < startLine) {
        // 変更された範囲より前の行は変更なし
        bookmarkLines.add(line);
      } else {
        // 変更された範囲以降の行は、追加/削除された行数分ずらす
        const newLine = line + lineCount - (endLine - startLine);
        if (newLine > 0) {
          bookmarkLines.add(newLine);
        }
      }
    }
  }

  /**
   * 文字種変換メニューを表示/非表示を切り替える
   */
  function toggleCaseMenu() {
    const menu = document.getElementById('caseMenu');
    menu.classList.toggle('show');

    // メニュー以外をクリックしたときにメニューを閉じる
    document.addEventListener('click', function closeMenu(e) {
      if (!e.target.closest('.dropdown')) {
        menu.classList.remove('show');
        document.removeEventListener('click', closeMenu);
      }
    });
  }

  /**
   * エディタで選択されたテキストを指定された形式に変換します。
   * 大文字、小文字、タイトルケース、全角、半角への変換に対応しています。
   * @param {string} type - 変換タイプ（'upper'：大文字、'lower'：小文字、'title'：タイトルケース、'fullWidth'：全角、'halfWidth'：半角）
   * 'fullWidth'または'halfWidth'が選択された場合、ASCII文字と全角文字の間で変換を行います。
   */
  function convertCase(type) {
    const targetEditor = getTargetEditor();
    const model = targetEditor.getModel();
    if (!model) return;
    const selections = targetEditor.getSelections();
    if (!selections) return;

    switch (type) {
      case 'upper':
        targetEditor.trigger('', 'editor.action.transformToUppercase');
        break;
      case 'lower':
        targetEditor.trigger('', 'editor.action.transformToLowercase');
        break;
      case 'title':
        targetEditor.trigger('', 'editor.action.transformToTitlecase');
        break;
      case 'fullWidth':
      case 'halfWidth':
        const ZEN_HAN_DIFF = 'Ａ'.charCodeAt(0) - 'A'.charCodeAt(0); // 差分を計算
        const edits = selections.map(selection => {
          const text = model.getValueInRange(selection);
          const convertedText = (type === 'fullWidth')
            ? text.replace(/[!-}]/g, s => String.fromCharCode(s.charCodeAt(0) + ZEN_HAN_DIFF))
            : text.replace(/[！-｝]/g, s => String.fromCharCode(s.charCodeAt(0) - ZEN_HAN_DIFF));
          return {
            range: selection,
            text: convertedText
          };
        });

        targetEditor.executeEdits('', edits);
        break;
    }

    // メニューを閉じる
    document.getElementById('caseMenu').classList.remove('show');
    targetEditor.focus();
  }

  /**
   * 現在のターゲットエディタを取得する
   * @returns {monaco.editor.IEditor} - ターゲットエディタ
   */
  function getTargetEditor() {
    if (!isDiffMode) {
      return editor;
    }
    // 差分モードの場合は、lastFocusedがあればそれを、なければ右側のエディタを返す
    return lastFocused || diffEditor.getModifiedEditor();
  }
</script>